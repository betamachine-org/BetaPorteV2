#!/usr/bin/perl
use strict;
use warnings;

#generated by openAi
use IO::Socket::INET;
use Time::HiRes qw(usleep time);

print "Start listenUDP\n";

STDOUT->autoflush(1);

# Create a new UDP socket
my $socket = new IO::Socket::INET (
    LocalPort => 23423, 
    Proto => 'udp',
	Blocking => 0
) or die "Error creating socket: $!\n";

# Infinite loop to keep the program running and listen for incoming packets
my $old_client_address = '';
my $old_trame_number = -1;
my $time; 
my $trameCnt = 0;
my $firstTrameTime = 0;

while (1) {
    my $data;
    my $client_address;
    my $client_port;
	$time = time;
    # Receive data from the socket
    if ($socket->recv($data, 1024, 0) ) {
		#print display_date_time_fr_ms();
		#print "\n" ;
    	# Get the address and port of the sender
    	$client_address = $socket->peerhost();
    	$client_port = $socket->peerport();
		
        if ($data =~ /^(\S+)\s+(\S+)\s+(.*)/) {
			
			$firstTrameTime = $time;
            my $w1 = $1;
            my $w2 = $2;
    	    #$line = $3;
                        # do something with the words and remainder
            if ( ($client_address ne $old_client_address) || ($w2 ne $old_trame_number) ) {
				if ($trameCnt > 0 ) {
	        		print "Got $trameCnt trames !!!\n";	
				}
			   $trameCnt = 0;
               my $time =  display_date_time_fr_ms(); 
               $old_trame_number = $w2;
               $old_client_address = $client_address;
			   chomp($data);
    	       print "at $time Received data from $client_address:$client_port: $data "; 
	    	}
			$trameCnt++;
		}
	} elsif ($trameCnt > 0 && $time - $firstTrameTime > 0.5) {
		print "Got $trameCnt trames\n";
		$trameCnt = 0;
    } else {
      # sleep(1); 	
      usleep(1000);     
    }
}

# Close the socket when the program exits
$socket->close();

use POSIX qw(strftime);

sub display_date_time_fr_ms {
    
    my $msec = sprintf("%03d",$time*1000 % 1000);
    my $result = strftime "%d/%m/%y, %T", localtime($time);
    $result = "$result,$msec" ;
 
    return $result;
}


